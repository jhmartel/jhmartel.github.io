<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="JHM">
<meta name="dcterms.date" content="2024-01-16">
<meta name="description" content="We have an idea on generative matchmaking in vintage clothing. This means generating items and complete outfits with confidence to customers. Easier said than done. Here we present the hypothesis that colour pattern preferences are the dominant factor when buying clothes. This means that a person’s outfits consists of combinations of colour patterns. This is necessary before any so-called machine learning methods can be applied.">

<title>jhm - Vintage Selling and Generative Matchmaking (Part 1)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../im1.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">jhm</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jhmartel/" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/_jhmlabs" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Vintage Selling and Generative Matchmaking (Part 1)</h1>
                  <div>
        <div class="description">
          We have an idea on generative matchmaking in vintage clothing. This means generating items and complete outfits with confidence to customers. Easier said than done. Here we present the hypothesis that colour pattern preferences are the dominant factor when buying clothes. This means that a person’s outfits consists of combinations of colour patterns. This is necessary before any so-called machine learning methods can be applied.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">vintage</div>
                <div class="quarto-category">generative</div>
                <div class="quarto-category">matchmaking</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>JHM </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 16, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p><em>This post is parallel to <a href="https://jhmartel.github.io/posts/2024-01-02-EconomicsVintageSelling/">our earlier post on vintage selling</a> and represents preliminary thoughts on vintage selling and generative matchmaking. This is key buzzword for 2024.</em></p>
<section id="supply-versus-demand-in-vintage-selling" class="level2">
<h2 class="anchored" data-anchor-id="supply-versus-demand-in-vintage-selling">Supply versus Demand in Vintage Selling</h2>
<p>Our impression is that the vintage clothing market has a significant gap between supply and demand. This gap is especially pronounced in quality used men’s clothing. By “gap” we mean that customers come to the store looking to spend money, they spend time going through the clothing, see nothing they like, and leave without buying anything. Why? Because they don’t see what they want, i.e.&nbsp;the supply does not overlap with the demand. This is the gap we’re talking about.</p>
<p>It appears the total space of customers is the sum of two distinct “mind sets” or “psychological states”. These two mindsets approximately correspond to “feminine” and “masculine” buyers, and are summarized in the idiom <em>“women shop. men buy.”</em> There’s many reference on this subject, for example:</p>
<p><a href="https://knowledge.wharton.upenn.edu/podcast/knowledge-at-wharton-podcast/men-buy-women-shop-the-sexes-have-different-priorities-when-walking-down-the-aisles/">Wharton School of Business Podcast</a></p>
<p><a href="https://www.washingtonpost.com/archive/lifestyle/magazine/1999/08/22/women-shop-men-buy/5ac9eb67-59aa-4294-ba9b-05a9ec2243e9/">Washington Post article from 1999</a></p>
<p><a href="https://www.junglescout.com/blog/men-vs-women-shopping/">Men versus Women shopping statistics</a></p>
<p>Our specific purpose here is to describe the strategy for the masculine psychological type. We propose the “masculine mind” is mission oriented and judgemental. They dislike the time required to search through random racks for items that may or may not be there, which may or may not fit, at this or that price, etc.. Other types find this aspect of vintage hunting fun, but our premise is that the “masculine” psychology does not enjoy this at all. This makes for significant barrier between these types of buyers and the vintage stores. Our hypothesis is this: the barrier is removed by <em>proactively generating</em> suggestions to the masculine customer.</p>
<p>Let’s make this concrete. A customer walks into the shop. Before the clients even look through the racks, can the vintage seller generate a list of ten items which positively interest the customer? I.e. items that the customer wants “Wow I have to have that!”.</p>
<p>The good news about the obnoxious loud mouth masculine type is this: they are willing to buy a whole setup now at a good price and leave happy. In and out. It really doesn’t have to be prolonged ordeal for anybody. Nobody has to random search through racks, unless they really want the “thrill”.</p>
</section>
<section id="problem-statement-generating-probabilities-of-sale-with-confidence" class="level2">
<h2 class="anchored" data-anchor-id="problem-statement-generating-probabilities-of-sale-with-confidence">Problem Statement: Generating Probabilities of Sale with Confidence</h2>
<p>We begin with a description of the process as we see it. The vintage seller has a supply <span class="math inline">\(X\)</span> of items. This supply is initially opaque and unknown to customers <span class="math inline">\(Y\)</span>. A customer <span class="math inline">\(y\)</span> walks into the shop, and they have a null feeling to mostly everything. For example, all the tshirts are hanging “side by side” with their graphics hidden, so the items all “look the same” in the customer’s eye. Maybe something catches their eye immediately, or perchance by random searching through the racks the customer <span class="math inline">\(y\)</span> sees something that strikes them.</p>
<p>It’s all about the eye and colour, perception and experience in the customer. Visibility is the primary cause of a sale. An extreme instance of this problem is at shop [X] which is very dark inside, and the racks are overstuffed with items, and there’s no room to move.</p>
<p>From another point of view, the vintage seller has no sense of the client’s preferences. The vintage seller likely doesn’t know the buyer even exists before they physically walk into the store. What’s the minimal amount of information that sellers should know about their average customers? We think there’s benefits to vintage sellers having the items ready for customers <em>before</em> the customers walk through the door! This sounds impossible, but there’s a way. It requires predicting the preference probabilities <span class="math inline">\(q(x,y)\)</span> with confidence. We’re using “<span class="math inline">\(q\)</span>” as placeholder for the probabilities which we are trying to predict, i.e.&nbsp;predicting the event of item <span class="math inline">\(x\)</span> selling to <span class="math inline">\(y\)</span>. The questions we want to answer are:</p>
<p>“<em>What is the probability of item <span class="math inline">\(x\)</span> being sold to <span class="math inline">\(y\)</span> at the sales price today?</em>”</p>
<p>“<em>When a customer walks into the shop, what are the high- and low- probability items relative to the customer <span class="math inline">\(y\)</span>’s preferences? i.e.&nbsp;for which <span class="math inline">\(x\)</span> is <span class="math inline">\(q(x,y)\)</span> more than fifty percent probable?</em>”</p>
<p>So we are asking about probabilities <span class="math inline">\(q\)</span> of items being sold to customers. The probabilities represented in <span class="math inline">\(q\)</span> are themselves uncertain. In otherwords, the customer <span class="math inline">\(y\)</span> doesn’t know what they want. This is where the art of curating a vintage collection enters: the seller sets the fashion and effectively tells the customer what to buy.</p>
</section>
<section id="knowing-your-audience-fitting-the-vetruvian-man-colour-preferences." class="level2">
<h2 class="anchored" data-anchor-id="knowing-your-audience-fitting-the-vetruvian-man-colour-preferences.">Knowing Your Audience, Fitting the Vetruvian Man, Colour Preferences.</h2>
<p>The problem is <em>knowing or not knowing your audience</em>. For the machine learning engineers, it raises the question <em>“What are the relevant numerical statistics worth knowing about your audience?”</em> We use <span class="math inline">\(x,y\)</span> as symbols intended to represent real items and real customers. But before we can perform any machine learning method, the symbols <span class="math inline">\(x,y\)</span> need to be correlated to floating point decimals. This is awkward process, and we try to keep it as simple as possible.</p>
<p>Ultimately fashion and clothing is about the human form. So the basis of everything is a person in their body:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="v1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Vetruvian Man needs clothes! What shirts, pants, shoes, jackets, etc.., does he prefer?</figcaption>
</figure>
</div>
<p>We imagine every customer is basically their own Vetruvian person, like universal mannequin. What does anybody need to know about Vetruvian man to recommend some clothing items? Obviously we don’t need a longform interview. In fact, it’s better to keep it as simple as possible. We think everything reduces to examples. The only thing the seller needs is a summarized precis of colour pattern combinations. Again we really are trying to keep it as simple as possible.</p>
<p><strong>Definition.</strong> A <em>colour pattern</em> is an <span class="math inline">\(RGB\)</span> valued measure <span class="math inline">\(\mu\)</span>. An <em>outfit</em> is a triple of colour pattern measures <span class="math inline">\(\mu_1, \mu_2, \mu_3\)</span>.</p>
<p>The idea is that a choice of outfit is formally represented as a choice of colour patterns <span class="math inline">\(\mu_i\)</span> on pants, undershirt, and overshirt. The definition suggests that a person’s preferences depends mostly on triplets of colour patterns. What defines a person’s style are their preferences relating to <em>combinations of colours</em>. We emphasize that it’s not strictly preferences in the colours themselves, but preferenecs in the combinations of the colour. The contrast and comparison of these distributions together, i.e.&nbsp;whether they clash or correlate, is how we represent the customer’s style preferences.</p>
<p>Personally the author thinks it’s amusing to wear homogeneous colour patterns, i.e.&nbsp;red on red, green on green, blue on blue. We like simplicity and think it’s fun when eveything adds up to “red plus red plus red equals red”. But in other settings its better to be balanced, having at most three primary colours, etc..</p>
<p>This makes us wonder about birds and their wonderful plumage. Is there experiment to decide whether birds share common preferences in the colour distributions? It’s curious question…</p>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>To summarize the discussion:</p>
<ol type="i">
<li><p>The theme is generative matchmaking. I.e. if the customers can only see ten items to potentially buy, then generate a list of ten items which have better odds than ten random items. I.e. quickly curate a personal list to the customer. This means predicting the probability <span class="math inline">\(q(x,y)\)</span> of the event of item <span class="math inline">\(x\)</span> being purchased by customer <span class="math inline">\(y\)</span> at the sale price. The purpose is to predict the most probable events, where the probability <span class="math inline">\(q\)</span> is maximized.</p></li>
<li><p>We hypothesize that customers buy items depending on colour patterns <span class="math inline">\(\mu\)</span> of the fabric. We assume that customers buy outfits depending on their preference for combination colour patterns <span class="math inline">\(\mu_1\)</span>, <span class="math inline">\(\mu_2\)</span>, <span class="math inline">\(\mu_3\)</span> of pants, undershirt, and overshirt.</p></li>
<li><p>We assume the high probability colour distributions of customers can be “learned from examples”.</p></li>
</ol>
<p>Our goal here is “setting the stage” for the generative model. We identify the colour pattern distributions as the main eye factor in choosing clothes. Personally we know we only like clothes that have good colours and tones. To actually code, train, deploy the generative model we are suggesting is the next step.</p>
<p>[To be continued – JHM]</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>