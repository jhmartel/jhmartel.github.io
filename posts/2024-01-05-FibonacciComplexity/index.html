<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="JHM">
<meta name="dcterms.date" content="2024-01-04">
<meta name="description" content="We review the complexity of Fibonacci’s sequence 1, 1, 2, 3, 5, 8, 13, etc., and its relation to S. Wolfram’s informal definition of computational irreducibility. We consider whether topological irreducibility has analogy to computation, and this is somewhat speculative, as we are looking for strategies to prove that O(log_2~N) is the minimal complexity of computing the Nth Fibonacci element f(N).">

<title>jhm - Computational Complexity of Fibonacci Sequences.</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">jhm</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jhmartel/" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/_jhmlabs" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Computational Complexity of Fibonacci Sequences.</h1>
                  <div>
        <div class="description">
          We review the complexity of Fibonacci’s sequence <span class="math inline">\(1, 1, 2, 3, 5, 8, 13,\)</span> etc., and its relation to S. Wolfram’s informal definition of computational irreducibility. We consider whether topological irreducibility has analogy to computation, and this is somewhat speculative, as we are looking for strategies to prove that <span class="math inline">\(O(log_2~N)\)</span> is the minimal complexity of computing the <span class="math inline">\(N\)</span>th Fibonacci element <span class="math inline">\(f(N)\)</span>.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">complexity</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>JHM </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 4, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p><em>This article was originally written circa October 2022. [-JHM]</em></p>
<p>Craig Alan Feinstein’s papers on <span class="math inline">\(P\)</span> not equal to <span class="math inline">\(NP\)</span> have caused us to review algorithms and complexity. We study “computational complexity” from the pragmatic perspective. This in contrast to “theoretical” computation results, which is a contradiction in terms.</p>
<p>Here we consider the question”:<em>“What is the computational complexity of computing the <span class="math inline">\(n\)</span>th Fibonacci number?</em></p>
<section id="naive-fibonacci-computation" class="level2">
<h2 class="anchored" data-anchor-id="naive-fibonacci-computation">Naive Fibonacci Computation</h2>
<p>Recall that the Fibonacci sequence is a sequence of integers <span class="math inline">\(f_0, f_1, f_2, \ldots\)</span> defined recursively by: <span class="math display">\[f_0=1, ~~ f_1=1, ~~\text{and}~~ f_{n+1}=f_n+f_{n-1}~~\text{for}~~ n\geq 1.\]</span></p>
<p>To naively compute <span class="math inline">\(f_{2022}\)</span> would require we repeatedly apply the recursive definition, finding <span class="math inline">\(f_[2022}:=f_{2021}+f_{2020}\)</span>, etc.. This procedure requires we compute all the values <span class="math inline">\(f_k\)</span> for <span class="math inline">\(k&lt; 2022\)</span>.</p>
<p>The pseudocode for this naive procedure is based on “memoization”. If we apply the above recursive formula to evaluate <span class="math inline">\(f_{2022}\)</span>, then we’ll be reusing the values <span class="math inline">\(f_k\)</span> for <span class="math inline">\(k &lt; 2022\)</span>. Memoization is simply a device for recording and reusing these intermediate values. So to compute <span class="math inline">\(f_{2022}\)</span> we will need to <em>store</em> the previous values, although there is a method (Bottom-Up evaluation) which is similar, and which inductively evaluates <span class="math inline">\(f_1\)</span>, <span class="math inline">\(f_2\)</span>, <span class="math inline">\(f_3\)</span>, etc., until we reach <span class="math inline">\(f_{2022}\)</span>.</p>
<p>So if we compute <span class="math inline">\(f_{2022}\)</span> and memoize all the terms <span class="math inline">\(m=\{f_1, f_2, f_3, \ldots\}\)</span>, then the memo <span class="math inline">\(m\)</span> grows unbounded in length. Some authors modify the memo to only contain the two “largest” elements, thus reducing the length of the list. This would require updating the memo <span class="math display">\[\{f_1, f_2\} \leadsto \{f_2, f_3\} \leadsto \{f_3, f_4\} \leadsto \cdots \leadsto \{f_{n-1}, f_n\} \leadsto \cdots.\]</span> But still the number of bytes necessary to represent the fibonacci elements grows exponentially with <span class="math inline">\(n\)</span> since <span class="math inline">\(f_{n+1} \approx \varphi^n\)</span> where <span class="math inline">\(\varphi\)</span> is the golden ratio <span class="math inline">\(\varphi=\frac{1+\sqrt{5}}{2} \approx 1.618033\)</span>.</p>
<p>The memoization gives a time complexity of <span class="math inline">\(O(n)\)</span> to compute <span class="math inline">\(f_n\)</span>. But memoization requires memory to store the memo! And we think this needs to be accounted for in the computational complexity, since obviously it’s an essential part of the <em>computation</em>. Indeed computation as represented by Turing machines, say, involves motion and read/write/react at different locations on the “tape”. It seems that a proper accounting of complexity should involve every time-step, namely every motion and site operation. In analyzing the complexity of the usual <span class="math inline">\(O(n)\)</span> complexity of computing <span class="math inline">\(f_n\)</span>, the action of calling and retrieving the data in the memo are considered to be constant.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Code taken from https://stackoverflow.com/a/61604929/17406611</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>fib_cache <span class="op">=</span> {<span class="dv">0</span> : <span class="dv">0</span>, <span class="dv">1</span> : <span class="dv">1</span>}</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib(n):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="kw">in</span> fib_cache:</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> fib_cache[n]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">100</span>, n, <span class="dv">100</span>):</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>      fib(i)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    fib_cache[n] <span class="op">=</span> result <span class="op">=</span> fib(n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib(n<span class="op">-</span><span class="dv">2</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># print(fib_cache) # &lt;--this line is diagnostic.</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># There's interesting comment on why the range(100, n, 100) line is important</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="co"># to avoid a "recursive depth error". The point is that the memo needs to be filled</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span class="co"># as the algorithm develops, otherwise it recurses too far and returns an error!</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-outputid="d4f73f8a-ede8-4960-8477-456d8e0854cc">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># crashes the RAM</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># fib(1111111)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>fib(<span class="dv">11111</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>515449135231559341621591189426925989418721609167804403107087312453694294479381404009230187092526675635022414542794904158934368158350216751867828729213516067642461147232232268304004580596220514978296704097915617589481297010691749471374967376304898014174716132125169572206688299944881902864940487579850754037243411123276226268998274067232370656873037885028569262362061989878439356579125363739644638605976667733232134130196207453194213358616463005487086631652051025004934485196108344869244852506414543015664379038338857611347469102943415360234480491921571800239803284078147859161629100936007246749423449323827401152142684138017539299637210829955409666781554035555164800825902557894478979141680264821730580654526990976167873657740460977594388216677737796493623940501749951993194553070912364327001564086186444836587037180810655016948562608480145057901528396467327800369394725748856906177005886944277609832795419082424474419033931754123200248752600310587761729439189440527073799320938597514569967706344559861576816209214912702962065352672071494639021231263782338510241176219316180788341549329905272081790433223099472061887224254193326845457247107409050092252994931668934553671721376871177693036352993174131508107261653495025271505086039171034392185521383307925723081097129536244468148375789733582131797176285225457221029865658845503179175504307577930140222583997281098099332145783930418777810346276337273420733754768191403158839413163368990092771464626510432292314209966950363068432367028332284209840897425718364670733733609565321893240873729315360915814803137552560521106490937691421540344502423323064743545226360364012549367167257038202145921861042955299329942301124074181956428710271876930526019606797077558959445434943166179407403375284366340173639269807373108055388080201746447050804598946499248800891171987624229020766742994219485280547337990630263452898332213470171667603200991268579583095661682595442200149483262133621860660302141160974707437100532341443580636798210704649175613121627855118061762876137389590812891131603206815601843823369210865672605256743142632199819790960079549275267815983406188538500072911327187912330503064073869613282412315795790671452556371408354045852898125070873750632615799469070245720036053071341314252092446074260578417947762296896685389368685659291620443322232933074723685001342680075497489</code></pre>
</div>
</div>
</section>
<section id="wolframs-nondefinition-of-computational-irreducibility." class="level2">
<h2 class="anchored" data-anchor-id="wolframs-nondefinition-of-computational-irreducibility."><em>Wolfram’s (non)Definition of Computational Irreducibility.</em></h2>
<p>In Wolfram’s book “A New Kind of Science”, there is introduced the idea of <em>computational irreducibility</em>. We quote from Chapter 13, pp.739-740.</p>
<p>[Begin quote:]</p>
<p>“<em>Computational irreducibility leads to a much more fundamental problem with prediction. For it implies that even if in principle one has all the information one needs to work out how some particular system will behave, it can still take an irreducible amount of computational work actually [sic] to do this.</em></p>
<p><strong><em>Indeed, whenever computational irreducibility exists in a system it means that in effect there can be no way to predict how the system will behave except by going through almost as many steps of computation as the evolution of the system itself.</em></strong></p>
<p><em>In traditional science it has rarely even been recognized that there is a need to consider how systems that are used to make predictions actually operate.</em></p>
<p><strong><em>But what leads to the phenomenon of computational irreducibility is that there is in fact always a fundamental competition between systems used to make predictions and systems whose behaviour one tries to predict.</em></strong></p>
<p><em>For if meaningful general predictions are to be possible, it must at some level be the case that the system making the predictions be able to </em><strong>outrun</strong>* the system it is trying to predict. But for this to happen the system making the predictions must be able to perform more sophisticated computations than the system is trying to predict.*</p>
<p><em>But the remarkable assertion that the Principle of Computational Equivalence makes is that this assumption is not correct, and that in fact almost any system whose behaviour is not obviously simple performs computations that are in the end exactly equivalent in their sophistication.</em></p>
<p><em>So what this means is that systems one uses to make predictions cannot be expected to do computations that are any more sophisticated than the computations that occur in all sorts of systems whose behaviour we might try to predict. And from this it follows that for many systems no systematic prediction can be done, so that there is no general way to shortcut their process of evolution, and as a result their behaviour must be considered computationally irreducible.</em>”</p>
<p>[End quote.]</p>
<p>Here’s what we like about Wolfram’s idea of “computational irreducibility”. Firstly it aligns with experience. Mathematicians who actually compute things know there’s no shortcuts for most operations. It’s very difficult to add two numbers <span class="math inline">\(a+b\)</span> without actually “adding” them arithmetically. This relates to Craig Alan Feinstein’s arguments that <span class="math inline">\(P \neq NP\)</span>, and specifically that the subset-sum problem is computationally irreducible. To decide whether a set of signed integers <span class="math inline">\(S\)</span> contains a zero subset-sum, there really is nothing we can do except exhaustively search through all the subsets and add the elements. But most theoretical computer scientists “dream” of somehow there existing a shortcut, a black box, a sophisticated magical algorithm that will compute the sums without actually computing them. So Wolfram’s idea of “computational irreducibility” is in opposition to the theoretical computer scientists’ optimism.</p>
<p>But what’s lacking is any rigorous proof or definition of <em>computational irreducibility</em>. If I had to make a pseudo-definition (intuitive) I would first say:</p>
<ul>
<li>a computation is the evaluation of a function <span class="math inline">\(f: X \to Y\)</span>, and the evaluation <span class="math inline">\(f\)</span> is <em>computationally irreducible</em> if the complexity of any equivalent composition <span class="math inline">\(g: X \to Z\)</span> and <span class="math inline">\(h: Z \to Y\)</span> with <span class="math inline">\(f = h \circ g\)</span> satisfies <span class="math display">\[c(f) \leq c(h) + c(g),\]</span> where <span class="math inline">\(c(f)\)</span> represents the “computational complexity” of evaluating a function <span class="math inline">\(f\)</span>.</li>
</ul>
<p>However the complexity <span class="math inline">\(c(f)\)</span> is not well-defined at this point.</p>
<p>But the idea is that a function <span class="math inline">\(f\)</span> always admits (nonunique!) compositions <span class="math inline">\(f=h \circ g\)</span>, and the question is whether these compositions <span class="math inline">\(h, g\)</span> can be any simpler than the evaluation of <span class="math inline">\(f\)</span> itself!</p>
<p>The above is not sufficiently rigorous since we have not defined <span class="math inline">\(c(f)\)</span>. Moreover <span class="math inline">\(c\)</span> is not defined on the category of functinons, since <span class="math inline">\(f=h\circ g\)</span> are identical functions from the categorical viewpoint. Our point is simply that identical functions are not necessarily identical computations!</p>
<p>For example, Wolfram would argue that the Collatz function arising in the Collatz conjecture <a href="https://www.youtube.com/watch?v=094y1Z2wpJg"><span class="math inline">\(3x+1\)</span> problem</a> is computationally irreducible. There are no shortcuts for evaluating the Collatz function, and therefore there will never be a <em>proof</em> of Collatz’ conjecture. This is why no mathematician should study the problem, because the results/outputs of the Collatz function cannot be logically established, they can only be <em>empirically</em> established by directly evaluating the Collatz function using the definition.</p>
</section>
<section id="topological-irreducibility" class="level2">
<h2 class="anchored" data-anchor-id="topological-irreducibility">Topological Irreducibility</h2>
<p>Let’s examine the word <em>irreducibility</em> somewhat more. Wikipedia has many references, but the primary definition (for our perspective) is the topological irreducibility. Here is the definition from Wikipedia</p>
<p><em>Definition</em>: (Reducible and Irreducible Topological Spaces) A topological space <span class="math inline">\(X\)</span> is reducible if it can be written as a union $ X= X_1 X_2$ of two closed proper subsets <span class="math inline">\(X_1, X_2\)</span> of <span class="math inline">\(X\)</span>.</p>
<p><em>Definition</em>: A topological space <span class="math inline">\(X\)</span> is irreducible (or hyperconnected) if it is not reducible. Equivalently, if all non empty open subsets of X are dense, or if any two nonempty open sets have nonempty intersection.</p>
<p>So the computational aspect of irreducibility would involve computing intersections of nontrivial open subsets of the space. Formally it would be better to provide the relative definition of irreducibility for subsets <span class="math inline">\(A \subset X\)</span>, but we just use the subspace topology on <span class="math inline">\(A\)</span> in <span class="math inline">\(X\)</span>. I.e., open subsets of <span class="math inline">\(A\)</span> are defined as intersections <span class="math inline">\(U \cap A\)</span> of open subsets <span class="math inline">\(U\)</span> of <span class="math inline">\(X\)</span>. It’s useful to introduce the relative definition because our first idea for defining computational complexity is to consider the topology of the graph of the function in question, i.e.&nbsp;<span class="math inline">\(graph(f) \subset X \times Y\)</span>. Now if we have a composition <span class="math inline">\(f = h \circ g\)</span>, then we obtain two graphs(!) namely <span class="math display">\[graph(h) \subset Z \times Y\]</span> and <span class="math display">\[graph(g)\subset X \times Z.\]</span></p>
<p>I suppose it would be interesting to determine whether the graph of the Collatz function is an irreducible topological subset of the product <span class="math inline">\(\bf{N} \times \bf{N}\)</span>. And here we need specific the topology of <span class="math inline">\(\bf{N}\)</span>, which is not so obvious, although perhaps the discrete topology is the most natural.</p>
<p>To this point we haven’t proved anything new, we’ve only conceptualized the problem, trying to more formally define “irreducibility”. We have yet to define the complexity <span class="math inline">\(c(f)\)</span> of a function although our idea is that <span class="math inline">\(c(f)\)</span> should reflect a property of <span class="math inline">\(graph(f)\)</span>. Dependancy on the graph of <span class="math inline">\(f\)</span> allows us to compare compositions <span class="math inline">\(f=h\circ g\)</span> and maybe develop comparisons between <span class="math inline">\(c(f)\)</span>, <span class="math inline">\(c(g)\)</span>, <span class="math inline">\(c(h)\)</span>, etc..</p>
<p>But the point is that we have a strategy now, and we can consult the literature by looking for techniques to prove the irreducibility of topological spaces. This is a general problem, and we can even begin with the more specialized case of algebraic geometry.</p>
<p>In algebraic geometry, if a variety is irreducible then what does that mean <em>in concrete terms</em> for the equations defining the variety? For hypersurfaces it means the variety can be described by two equations instead of one. For example a polynomial <span class="math inline">\(p(x)\)</span> is reducible if <span class="math inline">\(p(x)=q_1(x) . q_2(x)\)</span> for nontrivial polynomials <span class="math inline">\(q_1, q_2\)</span>. What’s interesting for polynomials is that the degrees of the products are strictly smaller, namely <span class="math display">\[deg(p) = deq(q_1)+deg(q_2).\]</span></p>
<p>But let’s hypothesize that the complexity of evaluating a degree <span class="math inline">\(d\)</span> polynomial is <span class="math inline">\(d\)</span>. Then the complexity of computing <span class="math inline">\(p=q_1 q_2\)</span> is <em>not</em> <span class="math inline">\(deg(p)\)</span> but actually <span class="math display">\[\max\{ deg(q_1), deg(q_2) \}.\]</span> This is assuming that the product <span class="math inline">\(p=q_1 . q_2\)</span> has constant time complexity, which is reasonable for real or complex numbers. So this is elementary examples of how topological reducibility relates to computational complexity. And this seems to be the beginning of maybe something more interesting.</p>
</section>
<section id="complexity-of-exponentiation" class="level2">
<h2 class="anchored" data-anchor-id="complexity-of-exponentiation">Complexity of Exponentiation</h2>
<p>There is a recurring idea in evaluating the complexity of exponentiations, and it’s based on taking successive squares based on the binary representations. This is where the <span class="math inline">\(O(log_2 ~n)\)</span> complexity algorithm for evaluating <span class="math inline">\(f_n\)</span> is derived. This speedup depends on the fact that the rule for defining the fibonacci sequence is linear and static, namely the infinite sequence of rules <span class="math inline">\(f_{n+1}=f_n+f_{n-1}\)</span> for <span class="math inline">\(n\geq 1\)</span> is almost only one rule <span class="math display">\[f_{*+1} = f_* + f_{*-1}.\]</span></p>
<p>This relates to the <em>observation</em> that iterated matrix powers of <span class="math display">\[Q=\begin{pmatrix}
1 &amp; 1 \\
1 &amp; 0 \end{pmatrix} \]</span> generate the Fibonacci sequence. Specifically we have the identity <span class="math display">\[
\begin{pmatrix}
f_{n+1} &amp; f_n \\
f_n &amp; f_{n-1} \end{pmatrix} = \begin{pmatrix}
1 &amp; 1 \\
1 &amp; 0 \end{pmatrix}^n.
\]</span></p>
<p>This identity has alot of different explanations, but it suggests the following “speedup” for computing <span class="math inline">\(f_n\)</span> for <span class="math inline">\(n\geq 2\)</span>. For example, to compute <span class="math inline">\(f(16)=f(2^4)\)</span> we can evaluate <span class="math display">\[Q, ~~~~~Q^2, ~~~~ Q^4=(Q^2)^2, ~~~~ Q^8=(Q^4)^2.\]</span> And this successive squaring of the previous result allows a <span class="math inline">\(log_2(n)\)</span> speedup of the Fibonacci computation.</p>
<p>Likewise <span class="math inline">\(f(15)\)</span> requires we compute all the powers <span class="math inline">\(Q, Q^2, Q^4, Q^8\)</span> and then take the product <span class="math display">\[Q.Q^2.Q^4.Q^8=Q^{15}.\]</span> This represents somewhat the “worst case”. Notice that here we need to store the powers <span class="math inline">\(Q^{2^k}\)</span>, <span class="math inline">\(k&gt;0\)</span>, in memory and then multiply these powers together. So what precisely is the complexity? We find it curious how the complexity of matrix multiplication remains an open question in computer science. There are various speedups, although the naive complexity is <span class="math inline">\(O(n^3)\)</span> although speedups to <span class="math inline">\(O(n^{2+\epsilon})\)</span> are possible for some specific small values of <span class="math inline">\(\epsilon\)</span>. We’ll let <span class="math inline">\(\tilde{m}\)</span> represent the complexity of multiplication of two matrices.</p>
<p>So the total complexity is counted like:</p>
<ol type="1">
<li>Complexity of evaluating <span class="math inline">\(log_2(n)\)</span> matrix powers is <span class="math inline">\(\tilde{m}. log_2(n)\)</span> time steps.</li>
<li>Complexity of <span class="math inline">\(log_2(n)\)</span> matrix multiplications is <span class="math inline">\(\tilde{m}. log_2(n)\)</span> time steps.</li>
<li>Total Complexity is the sum of the complexities in 1. and 2., and therefore equal to <span class="math inline">\(\tilde{m}. log_2(n)\)</span>, or <span class="math inline">\(O(log_2n)\)</span></li>
</ol>
<p>Are the methods of computing the fibonacci sequence really different? Obviously one appears to be <em>faster</em>, requiring nominally less time steps or elementary operations. However there are increasing memory constraints arising from the matrix form, having to store the powers <span class="math inline">\(Q^{2^k}\)</span>, and where of course the entries are becoming super exponentially large.</p>
</section>
<section id="so-what" class="level2">
<h2 class="anchored" data-anchor-id="so-what">So What?</h2>
<p>Fair question. But as we said, this is the beginning of maybe something deeper. So we need to compare the two algorithms, and perhaps address whether the final <span class="math inline">\(O(log_2~n)\)</span> is really <em>irreducible</em> in Wolfram’s sense.</p>
<p>[To be continued … -JHM]</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>