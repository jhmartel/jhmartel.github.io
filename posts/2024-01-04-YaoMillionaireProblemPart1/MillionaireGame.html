<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="JHM">
<meta name="dcterms.date" content="2024-01-03">
<meta name="description" content="We begin the study of Yao’s Millionaire Problem, approaching via convex analysis. Two players have secret points, and the first player to guess an affine function separating the secrets wins. The question is whether the optimal strategy is uniform on the domain, or whether there is some variation in the density. This is elaborated below using both python and some elementary convex analysis">

<title>jhm - On Yao’s Millionaire Problem. Part 1.</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">jhm</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About JHM</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jhmartel/" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/_jhmlabs" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">On Yao’s Millionaire Problem. Part 1.</h1>
                  <div>
        <div class="description">
          We begin the study of Yao’s Millionaire Problem, approaching via convex analysis. Two players have secret points, and the first player to guess an affine function separating the secrets wins. The question is whether the optimal strategy is uniform on the domain, or whether there is some variation in the density. This is elaborated below using both python and some elementary convex analysis
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">secret</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>JHM </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 3, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>[<em>Originally written February 2022 … –JHM</em> ]</p>
<p>The purpose of this article is to investigate whether there is strategy or skill possible in the following variation of <a href="https://en.wikipedia.org/wiki/Yao%27s_Millionaires%27_problem">Yao’s “Millionaire Problem”</a>.</p>
<p>Here is the game. We have a huge grid <span class="math inline">\(\mathbf{R}^2\)</span>. Now let two players <span class="math inline">\(A,B\)</span> have secret locations <span class="math inline">\(s_A=(x_A, y_A)\)</span> and <span class="math inline">\(s_B=(x_B, y_B)\)</span>. These secrets are <em>points</em> in the euclidean plane <span class="math inline">\(\mathbf{R}^2\)</span>.</p>
<p>Now the players <span class="math inline">\(A, B\)</span> are going to take turns guessing affine functions (or affine lines in <span class="math inline">\(\mathbf{R}^2\)</span>) and the first player to guess an affine function which separates the secrets wins!</p>
<p>The gameplay is something like this: The players <span class="math inline">\(A,B\)</span> take turns. If player <span class="math inline">\(A\)</span> goes first, then player <span class="math inline">\(A\)</span> chooses an affine function <span class="math inline">\(\ell\)</span> on <span class="math inline">\(\mathbf{R}^2\)</span>, and asks player <span class="math inline">\(B\)</span> to reply with the sign of <span class="math inline">\(\ell(s_B)\)</span>. We require that <span class="math inline">\(B\)</span> replies honestly with <span class="math inline">\(sgn(\ell(s_B))\)</span>. This is the end of player <span class="math inline">\(A\)</span>’s turn. If <span class="math inline">\(\ell\)</span> separates the secrets, then player A wins. Otherwise it’s player B’s turn. Next player <span class="math inline">\(B\)</span> chooses an affine function <span class="math inline">\(\ell'\)</span>, and asks player <span class="math inline">\(A\)</span> to reply with the sign of <span class="math inline">\(\ell'(s_A)\)</span>. Once player <span class="math inline">\(A\)</span> replies, then this is the end of player <span class="math inline">\(B\)</span>’s turn. Again, if <span class="math inline">\(\ell'\)</span> separates the secrets, then player B wins. Otherwise it’s player A’s turn.</p>
<p>The object of the game is to determine an affine function <span class="math inline">\(\ell\)</span> which separates the secrets, i.e.&nbsp;for which $ sgn((s_A)) sgn((s_B)).$ The first player to demonstrate an affine function which separates the secrets wins!</p>
<p>Our interest is to find optimal strategies for this game. Firstly, we have to consider whether <em>any</em> strategy is even possible. For example, can player <span class="math inline">\(A\)</span> use the cumulative history of both player <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>’s affine guesses to better inform their next guess? For example, if player <span class="math inline">\(A\)</span> guesses an affine function <span class="math inline">\(\ell\)</span> which does not separate, then player <span class="math inline">\(B\)</span> can use the knowledge of their own private secret to determine which halfspace contains <span class="math inline">\(s_A\)</span>. And indeed, by the same reasoning player <span class="math inline">\(A\)</span> can use their knowledge of <span class="math inline">\(s_A\)</span> to likewise determine which halfspace contains <span class="math inline">\(s_B\)</span>. So obviously the initial distribution <span class="math inline">\(d\lambda\)</span> is updated to the restricted distribution <span class="math inline">\(d\lambda\cdot 1_H\)</span>, where <span class="math inline">\(H\)</span> is the halfspace defined by <span class="math inline">\(\ell\)</span> and containing <span class="math inline">\(s_A, s_B\)</span>. With successive guesses, the distribution becomes a descending chain of closed convex sets, namely the intersection of successive halfspaces, having the form <span class="math display">\[d\lambda \leadsto d\lambda \cdot 1_H \leadsto d\lambda \cdot 1_H 1_{H'} \leadsto d\lambda \cdot 1_H 1_{H'} 1_{H''} \leadsto \cdots. \]</span></p>
<p>The notation is somewhat strange, but simply expresses that we remain uncertain of the specific location of the secrets <span class="math inline">\(s_A, s_B\)</span>, except we know the possibly location is becoming more restricted.</p>
<p>In the millionaire game, the players <span class="math inline">\(A,B\)</span> have an interest in <em>privacy</em>. Their secrets <span class="math inline">\(s_A, s_B\)</span> are intended to be <em>secret</em>. This means the players <span class="math inline">\(A,B\)</span> might not choose affine functions which potentially reveal information about their own secrets. In practice this means players determined to maintain their privacy will always choose affine functions which do not bound compact convex sets. Similarly, an opponent will not readily choose affine functions which separates the domain into a bounded component, since the probability that the opponent’s secret lies in the bounded component is relatively small, while the probability of its lying in the unbounded component is much greater.</p>
<p>The subject of so-called <em>zero knowledge proofs</em> in cryptography is related to the millionaires problem. Here we try to find a balance where the players can choose to reveal as much as they wish of their own balances, while their own guesses are signals/indications in-themselves of the secret balance.</p>
<p>Our question is whether there is any strategy or skill in this game. What is the optimal strategy? Can the player use the knowledge of the opponent’s affine functions to improve their own selection of affine function??</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Now we simulate the millionaire problem on the euclidean two-dimensional plane.</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># For convenience we rename the players $A,B$ as players $+1, -1$, respectively.</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># for testing purposes we suppose the players A,B have secrets below:</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">#s_A=input("What is player A's secret position?")</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>s_A<span class="op">=</span>[<span class="dv">16</span>,<span class="dv">0</span>]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>s_A<span class="op">=</span>np.array(s_A)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">#s_B=input("What is player B's secret position?")</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>s_B<span class="op">=</span>[<span class="dv">0</span>, <span class="fl">0.2</span>]</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>s_B<span class="op">=</span>np.array(s_B)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co"># now we define some basic functions, i.e. to compute affine functions based on</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co"># their normal n and height b.</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> affine(n,x,b):</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span>np.array(n)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span>np.array(x)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>   <span class="co"># return n.dot(x)+b</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n[<span class="dv">0</span>]<span class="op">*</span>x[<span class="dv">0</span>]<span class="op">+</span>n[<span class="dv">1</span>]<span class="op">*</span>x[<span class="dv">1</span>] <span class="op">+</span> b</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="co"># to protect the secret we really only need the sign of the affine function.</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sign(x_Real):</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> x_Real<span class="op">&lt;</span><span class="dv">0</span>:</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">+</span><span class="dv">1</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="co"># here t defines the test function, which returns True iff the affine function</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="co"># separates the secrets. True is returned if the signs of the affine function</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="co"># evaluated on the secrets are not equal.</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> t(n,b):</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    n<span class="op">=</span>np.array(n)</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> sign(affine(n,s_A,b)) <span class="op">!=</span> sign(affine(n,s_B, b)):</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>         <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>         <span class="cf">return</span> <span class="va">False</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-outputid="fc7173f6-8563-42a7-e3fc-ad8156d47d20">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Now we setup the basic routine, i.e. sequence of gameplay.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">#initial conditions.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>outcome<span class="op">=</span><span class="va">False</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>history<span class="op">=</span>[]</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>vector_history<span class="op">=</span>[]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>player<span class="op">=+</span><span class="dv">1</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>i<span class="op">=</span><span class="dv">0</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>color<span class="op">=</span>[]</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> outcome <span class="op">==</span> <span class="va">False</span>:</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> Player "</span> <span class="op">+</span> <span class="bu">str</span>(player) <span class="op">+</span> <span class="st">"'s turn to play:"</span> )</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Given the history "</span> <span class="op">+</span> <span class="bu">str</span>(history) <span class="op">+</span> <span class="st">" choose your affine function:"</span>)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    n0 <span class="op">=</span> <span class="bu">float</span>(<span class="bu">input</span>())</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    n1 <span class="op">=</span> <span class="bu">float</span>(<span class="bu">input</span>())</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> <span class="bu">float</span>(<span class="bu">input</span>())</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    history <span class="op">=</span> history <span class="op">+</span> [[n0, n1, b]]</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    vector_history<span class="op">=</span>vector_history <span class="op">+</span> [[n0, n1]]</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    i<span class="op">=</span>i<span class="op">+</span><span class="dv">1</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> t([n0, n1], b) <span class="op">==</span> <span class="va">True</span>:</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        outcome <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Winner! Player "</span> <span class="op">+</span> <span class="bu">str</span>(player)<span class="op">+</span> <span class="st">" has separated the secrets with "</span> <span class="op">+</span> <span class="bu">str</span>([n0, n1, b]) <span class="op">+</span> <span class="st">". End of Game!"</span>)</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Fail! Player "</span> <span class="op">+</span> <span class="bu">str</span>(player) <span class="op">+</span> <span class="st">" has failed to separate the secrets... End of turn."</span>)</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        player<span class="op">=</span>player<span class="op">*</span>(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="co"># the following plots the various normals chosen by the players, but we would</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a><span class="co"># prefer to have the half spaces.</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    V<span class="op">=</span>np.array(vector_history)</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>    origin<span class="op">=</span>np.array([[<span class="dv">0</span>]<span class="op">*</span>i, [<span class="dv">0</span>]<span class="op">*</span>i])</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    plt.quiver(<span class="op">*</span>origin, V[:,<span class="dv">0</span>], V[:,<span class="dv">1</span>], scale<span class="op">=</span><span class="dv">21</span>)</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
 Player 1's turn to play:
Given the history [] choose your affine function:
1
1
0
Fail! Player 1 has failed to separate the secrets... End of turn.

 Player -1's turn to play:
Given the history [[1.0, 1.0, 0.0]] choose your affine function:
3
1
0
Fail! Player -1 has failed to separate the secrets... End of turn.

 Player 1's turn to play:
Given the history [[1.0, 1.0, 0.0], [3.0, 1.0, 0.0]] choose your affine function:
1
4
0
Fail! Player 1 has failed to separate the secrets... End of turn.

 Player -1's turn to play:
Given the history [[1.0, 1.0, 0.0], [3.0, 1.0, 0.0], [1.0, 4.0, 0.0]] choose your affine function:
-3
0
-5
Fail! Player -1 has failed to separate the secrets... End of turn.

 Player 1's turn to play:
Given the history [[1.0, 1.0, 0.0], [3.0, 1.0, 0.0], [1.0, 4.0, 0.0], [-3.0, 0.0, -5.0]] choose your affine function:
-1
-4
2
Winner! Player 1 has separated the secrets with [-1.0, -4.0, 2.0]. End of Game!</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="MillionaireGame_files/figure-html/cell-3-output-2.png" class="img-fluid"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="MillionaireGame_files/figure-html/cell-3-output-3.png" class="img-fluid"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="MillionaireGame_files/figure-html/cell-3-output-4.png" class="img-fluid"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="MillionaireGame_files/figure-html/cell-3-output-5.png" class="img-fluid"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="MillionaireGame_files/figure-html/cell-3-output-6.png" class="img-fluid"></p>
</div>
</div>
<p>The above is a very simple gameplay, where it happens by chance that the two points can be separated by a flat strip, namely the space between two parallel halfspaces. We included the above simply as an example.</p>
<p>[To Do:] 1. Use matplotlib to plot the halfspaces, and not simply the normal vector, which is what we have above.</p>
<ol start="2" type="1">
<li><p>Determine some automatic routine to compete with a human opponent.</p></li>
<li><p>The millionaire’s problem implicitly assumes the players <span class="math inline">\(A,B\)</span> have large funds, i.e.&nbsp;enough to pay for a dinner! Therefore we might need assume our secrets <span class="math inline">\(s_A, s_B\)</span> are sufficiently far from the origin. (?)</p></li>
<li><p>If the domain is essentially infinite, then a certain amount of privacy will always be maintained, because it’s better to bisect the unknown into two halfspaces of equal (possibly infinite) area. If the affine function indeed separates the secrets, then the position of that secret is only known to occupy an infinite area domain, and thus essentially remains private in a restricted sense. Although of course the <em>direction</em> of the secret, and not necessarily its magnitude will be better known to the opponent, i.e.&nbsp;there will be a definite reduction of uncertainty in the direction of the opponents secret, but not necessarily a reduction in uncertainty in its magnitude.</p></li>
</ol>
<p>If an opponent proposes an affine function which separates the domain into a bounded and unbounded component, then that is huge risk for the player, i.e.&nbsp;it’s unlikely that the small bounded domain (chosen at random) will contain the secret as opposed to the infinite domain. At the risk of belabouring the point: a random infinite domain is more likely to contain an unknown secret than a compact domain. We find this an interesting point…</p>
<div class="cell" data-outputid="92e21439-88bb-4b26-a2e1-112c11b63692">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.spatial <span class="im">import</span> HalfspaceIntersection</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>prehistory <span class="op">=</span> history[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>signs<span class="op">=</span>[]</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>sph<span class="op">=</span>[]</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> prehistory:</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    epsilon<span class="op">=</span>sign(affine([x[<span class="dv">0</span>], x[<span class="dv">1</span>]], s_A, x[<span class="dv">2</span>]))</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    signs<span class="op">=</span>signs<span class="op">+</span>[epsilon]</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    sph<span class="op">=</span>sph<span class="op">+</span>[epsilon<span class="op">*</span>np.array(x)]</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>sph<span class="op">=</span>np.array(sph)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co"># for illustration we have the secret s_A as feasible_point.</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="co"># its interesting question to select a feasible point which</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="co"># does not reveal too much information about the secrets...</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="co"># but obviously any point on the convex hull formed by the secrets s_A, s_B</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="co"># will be a feasible point. But there are many more choices, so which choice reveals</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="co"># the least information about the secrets s_A, s_B ? I.e. which feasible point can be chosen</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="co"># which reveals the least information about s_A, s_B?</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>feasible_point <span class="op">=</span> np.array([<span class="fl">16.0</span>, <span class="fl">0.0</span>])</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>halfspaces <span class="op">=</span> sph<span class="op">*</span>(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="co"># we need reverse-signs to align with the convention in qhull that</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a><span class="co"># the halfspaces are defined by the inequality Ax+b &lt;= 0.</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>hs <span class="op">=</span> HalfspaceIntersection(halfspaces, feasible_point)</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="st">'111'</span>, aspect<span class="op">=</span><span class="st">'equal'</span>)</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>xlim, ylim <span class="op">=</span> (<span class="op">-</span><span class="dv">100</span>, <span class="dv">100</span>), (<span class="op">-</span><span class="dv">100</span>, <span class="dv">100</span>)</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(xlim)</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(ylim)</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">100</span>, <span class="dv">100</span>, <span class="dv">1000</span>)</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>symbols <span class="op">=</span> [<span class="st">'-'</span>, <span class="st">'+'</span>, <span class="st">'x'</span>, <span class="st">'*'</span>]</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>signs <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>fmt <span class="op">=</span> {<span class="st">"color"</span>: <span class="va">None</span>, <span class="st">"edgecolor"</span>: <span class="st">"b"</span>, <span class="st">"alpha"</span>: <span class="fl">0.5</span>}</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> h, sym, sign <span class="kw">in</span> <span class="bu">zip</span>(halfspaces, symbols, signs):</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>    hlist <span class="op">=</span> h.tolist()</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>    fmt[<span class="st">"hatch"</span>] <span class="op">=</span> sym</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> h[<span class="dv">1</span>]<span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>        ax.axvline(<span class="op">-</span>h[<span class="dv">2</span>]<span class="op">/</span>h[<span class="dv">0</span>], label<span class="op">=</span><span class="st">'</span><span class="sc">{}</span><span class="st">x+</span><span class="sc">{}</span><span class="st">y+</span><span class="sc">{}</span><span class="st">=0'</span>.<span class="bu">format</span>(<span class="op">*</span>hlist))</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>        xi <span class="op">=</span> np.linspace(xlim[sign], <span class="op">-</span>h[<span class="dv">2</span>]<span class="op">/</span>h[<span class="dv">0</span>], <span class="dv">1000</span>)</span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>        ax.fill_between(xi, ylim[<span class="dv">0</span>], ylim[<span class="dv">1</span>], <span class="op">**</span>fmt)</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>        ax.plot(x, (<span class="op">-</span>h[<span class="dv">2</span>]<span class="op">-</span>h[<span class="dv">0</span>]<span class="op">*</span>x)<span class="op">/</span>h[<span class="dv">1</span>], label<span class="op">=</span><span class="st">'</span><span class="sc">{}</span><span class="st">x+</span><span class="sc">{}</span><span class="st">y+</span><span class="sc">{}</span><span class="st">=0'</span>.<span class="bu">format</span>(<span class="op">*</span>hlist))</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>        ax.fill_between(x, (<span class="op">-</span>h[<span class="dv">2</span>]<span class="op">-</span>h[<span class="dv">0</span>]<span class="op">*</span>x)<span class="op">/</span>h[<span class="dv">1</span>], ylim[sign], <span class="op">**</span>fmt)</span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>x, y <span class="op">=</span> <span class="bu">zip</span>(<span class="op">*</span>hs.intersections)</span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>ax.plot(x, y, <span class="st">'o'</span>, markersize<span class="op">=</span><span class="dv">8</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[ 1.  1.  0.]
 [ 3.  1.  0.]
 [ 1.  4.  0.]
 [ 3. -0.  5.]]
&lt;class 'numpy.ndarray'&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="MillionaireGame_files/figure-html/cell-4-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>The above intersection of halfspaces isn’t what i expected. The complete intersection is the sector in the upper right hand corner.</p>
<p>Now if we are truly taking secret points <span class="math inline">\(s_A, s_B\)</span> at random in <span class="math inline">\(\mathbf{R}^2\)</span>, then almost all random choices of affine functions will not separate the secrets. For example, given the homogeneity of <span class="math inline">\(\mathbf{R}^2\)</span>, we can consider the secrets <span class="math inline">\(s_A, s_B\)</span> as being extremely close such that they are basically coincident, or at least as seen from a far distance. But then a random choice of affine function is extremely unlikely to contain the two points. Thus it appears that truly random choices of affine functions have essentially zero probability of separating the secrets.</p>
<p>This leads to the next step in our study of the Millionaire Problem, namely where the initial distribution on <span class="math inline">\(\mathbf{R}^2\)</span> is not necessarily uniform. E.g., perhaps we know that the secrets are distributed within a given large radius ball. If we have no other information about the secrets except that it lies somewhere on the large ball <span class="math inline">\(D\)</span>, then one probabilistic strategy is to <em>bisect the ball</em> with affine functions, i.e.&nbsp;randomly guess an affine <span class="math inline">\(\ell\)</span> such that $ 1_D 1_{&gt;0}$ and <span class="math inline">\(1_D 1_{\ell &gt; 0}\)</span> have equal area.</p>
<p>But what about <em>privacy</em>? In the previous case where the distribution was uniform on its support on <span class="math inline">\(\mathbf{R}^2\)</span>, the privacy of the secrets was maintained so long as the affine functions were unbounded (from above and below). And the opponents would always guess such affine functions because there odds of correctly separating the secrets is significantly increased. But now its possible that the distribution will not be uniform on its support, and therefore the secrets can be learned with a reduction in uncertainty, i.e.&nbsp;perhaps we know that the opponents secret lies in a bounded set, or that 90% percent of the time the opponents secret lies in a given domain.</p>
<p>We remark that there is something like a “maximum likelihood” principle being used here. Now regarding privacy: if the domain <span class="math inline">\(D\)</span> is bounded, then depending on the distribution, the secret might have diminished privacy. This leads to Part 2 of our study, where the secrets are distibuted according to nonuniform distributions <span class="math inline">\(\mu_A\)</span>, <span class="math inline">\(\mu_B\)</span> on <span class="math inline">\(\mathbf{R}^2\)</span>.</p>
<ol type="a">
<li><p>What is the optimal strategy for nonuniform initial distributions <span class="math inline">\(\mu_A, \mu_B\)</span> ?</p></li>
<li><p>Can we quantify the “loss” of privacy when the distributions are supported on unbounded domains versus bounded domains?</p></li>
</ol>
<p><em>(To be continued…)</em></p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>